#!/bin/bash

set -x

error_handler() {
   local return_code="$?"
   local bash_command="$BASH_COMMAND"
   if [ "$ID" = "" ] ; then
      ID="No_ID"
   fi
   echo "$ID ERROR: return_code: $return_code | bash_command: $bash_command" >> /var/log/controlportfilt
   exit 1
}

trap error_handler ERR

OIFS="$IFS"
IFS="$OIFS"

## Do not use echos for user or debug output,
## because those are send back to the client, which gets confused.

ID="$(uuidgen -r)"

echo "$ID INFO: Getting connection... " >> /var/log/controlportfilt

## {{{ /etc/controlportfilt.d

if [ -d /etc/controlportfilt.d ]; then
   for i in /etc/controlportfilt.d/*; do
      if [ -f "$i" ]; then
         ## If the last character is a ~, ignore that file,
         ## because it was created by some editor,
         ## which creates backup files.
         if [ "${i: -1}" = "~" ]; then
            continue
         fi
         ## Skipping files such as .dpkg-old and .dpkg-dist.
         if ( echo "$i" | grep -q ".dpkg-" ); then
            true "skip $i"
            continue
         fi         
         source "$i"
      fi
   done
else
   echo "$0 ERROR: configuration folder /etc/controlportfilt.d does not exist."
   exit 1
fi

## }}}

## {{{ CONTROL_PORT_FILTER_LOWERCASE_WHITELIST

i=0
for element in "${CONTROL_PORT_FILTER_WHITELIST[@]}"; do
   CONTROL_PORT_FILTER_LOWERCASE_WHITELIST[$i]="${element,,}"
   i=$((${i} + 1))
done 

for element in "${CONTROL_PORT_FILTER_LOWERCASE_WHITELIST[@]}"; do
   true "CONTROL_PORT_FILTER_LOWERCASE_WHITELIST element: $element"
done

## }}}

write_back() {
   IFS="$OIFS"
   printf "${1+"$@"}\r\n"
   echo "$ID BACK: ${1+"$@"}" >> /var/log/controlportfilt
}

received() {
   IFS="$OIFS"
   true "${1+"$@"}"
   echo "$ID GOT: ${1+"$@"}" >> /var/log/controlportfilt
}

while read -r; do

   IFS="$OIFS"

   cleaned_reply="$REPLY"
 
   ## strip newlines from input
   cleaned_reply="$(echo "$cleaned_reply" | tr '\r' ' ')"
   cleaned_reply="$(echo "$cleaned_reply" | tr '\n' ' ')"
   
   ## strip trailing empty spaces from input
   cleaned_reply="$(echo "$cleaned_reply" | sed -e "s/ \{1,\}$//")"   
   
   received "$cleaned_reply"
 
   if [ "$cleaned_reply" = "" ]; then
      write_back '510 Unrecognized command ""'
      continue
   fi

   first="$(echo "$cleaned_reply" | awk '{print $1}')"   

   ## We do not check any control port password or auth cookies here,
   ## because only only safe commands are accepted anyway. Whonix-Workstation
   ## has no access to auth password / auth cookie anyway and sharing such a
   ## secret would be difficult.
   ## The only useful thing here could be to check if Tors control port is
   ## available at all, but this would also make this script even slower.
   
   if [ "${first,,}" = "authenticate" ]; then
      write_back "250 OK"
      continue
   fi
   
   if [ "${first,,}" = "quit" ]; then
      break
   fi
   
   ok="0"
   for element in "${CONTROL_PORT_FILTER_LOWERCASE_WHITELIST[@]}"; do
      true "CONTROL_PORT_FILTER_LOWERCASE_WHITELIST element: $element"      

      if [ "${cleaned_reply,,}" = "$element" ]; then
         ok="1"
         true "ok: reply ${cleaned_reply,,} = element $element"
         break
      fi     
   done
   
   if [ ! "$ok" = "1" ]; then
      write_back "510 Prohibited command \"$cleaned_reply\""
      continue
   fi
   
   ## Lie when we are asked "GETINFO net/listeners/socks". 
   ## This is documented on Whonix Control Port Filter Proxy Design page,
   ## search for lie.
   lie_when="GETINFO net/listeners/socks"
   
   if [ "${cleaned_reply,,}" = "${lie_when,,}" ]; then
      true "Got \"$cleaned_reply\" let's lie and forge the answer to make Tor Button happy."
      write_back '250-net/listeners/socks="127.0.0.1:9150"'
      continue
   fi   

   tor_ctrl_return="0"
   var="$(tor-ctrl -v -s 0 -P 9051 -a /var/run/tor/control.authcookie -c "$cleaned_reply")" || { tor_ctrl_return="$?" ; true; }
   
   if [ ! "$tor_ctrl_return" = "0" ]; then
      echo "$ID ERROR: tor-ctrl returned a non-zero exit code: $tor_ctrl_return. var: $var | Let's try again..." >> /var/log/controlportfilt
      
      tor_ctrl_return="0"
      var="$(tor-ctrl -v -s 0 -P 9051 -a /var/run/tor/control.authcookie -c "$cleaned_reply")" || { tor_ctrl_return="$?" ; true; }
      
      if [ ! "$tor_ctrl_return" = "0" ]; then
         echo "$ID ERROR: tor-ctrl returned again a non-zero exit code: $tor_ctrl_return. var: $var | Breaking." >> /var/log/controlportfilt
         break
      fi
   fi
 
   ## split at newlines only
   IFS='
'

   for line in $var; do
   
      #true "line: $line"

      #set +x
      if [ "$line" = "Trying 127.0.0.1..." ]; then
         previous_line="$line"
         continue
      fi     
      if [ "$line" = "Connected to 127.0.0.1." ]; then
         previous_line="$line"
         continue
      fi    
      if [ "$line" =  "Escape character is '^]'." ]; then
         previous_line="$line"
         continue
      fi
      if [ "$line" = "250 closing connection" ]; then
         previous_line="$line"
         continue
      fi
      if [ "$line" = "250 OK" ]; then
         if [ "$previous_line" = "Escape character is '^]'." ]; then
            previous_line="$line"
            continue
         fi         
      fi
      #set -x

      write_back "$line"
      
      previous_line="$line"
   done

   IFS="$OIFS"

done

IFS="$OIFS"

echo "$ID INFO: End. " >> /var/log/controlportfilt
